[
    {
        "id": "1328b7036b2b840e",
        "type": "tab",
        "label": "06_Berechnung",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "55bcd0f499ed66d6",
        "type": "inject",
        "z": "1328b7036b2b840e",
        "name": "Anfansgwerte & Max-Werte",
        "props": [
            {
                "p": "batt_nom",
                "v": "65.3",
                "vt": "num"
            },
            {
                "p": "batt_status_start",
                "v": "0.4",
                "vt": "num"
            },
            {
                "p": "batt_status_final",
                "v": "0.7",
                "vt": "num"
            },
            {
                "p": "energyL_max",
                "v": "32.6",
                "vt": "num"
            },
            {
                "p": "energyE_max",
                "v": "50",
                "vt": "num"
            },
            {
                "p": "batt_status_min",
                "v": "0.2",
                "vt": "num"
            },
            {
                "p": "batt_status_max",
                "v": "0.9",
                "vt": "num"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 220,
        "y": 220,
        "wires": [
            [
                "1af8a7b7ca10e78b"
            ]
        ]
    },
    {
        "id": "1af8a7b7ca10e78b",
        "type": "function",
        "z": "1328b7036b2b840e",
        "name": "Parse_Daten",
        "func": "var obj = global.get(\"04_FinalObjekt\");\nvar strompreis = [];\nvar e_pv=[];\nvar e_v =[];\nvar e_bn = msg.batt_nom; //aus dem Akkuspeicher von Schulz in kWh. Nom.Energie -- Wert im Inject ändern.\nvar soc_0 = msg.batt_status_start; //40% Ladezustand der Batterie am Anfang -- Wert im Inject ändern.\nvar soc_23 = msg.batt_status_final;\nvar soc_min =msg.batt_status_min;\nvar soc_max =msg.batt_status_max;\nvar el_max = msg.energyL_max;\nvar ee_max = msg.energyE_max;\n\nvar obj_temp = new Object;\nvar zielfunktion = \"Q = ∑ Strompreis_(i) * E_Netz_(i)\";\nvar condition1 = \"E_L <= 32.6 kWh  && E_L >=0\\n\";\nvar condition2 = \"E_E <= 50 kWh  && E_E >=0\\n\";\nvar condition3 = \"SoC >=0.2 && Soc <= 0,9\\n\";\nvar batt_min = 13.06;\nvar batt_max = 58.77;\nobj_temp.data = {};\nobj_temp.info = {};\nvar q_normal = 0;\nvar q_nominal = 0;\n\nfor (var i = 0; i<24; i++)\n{\n    //var number = data[i].replace(',', '.');\n    //number = parseFloat(number);\n\n    var preis = obj[i].Strompreis.Preis;\n    var photo = obj[i].Photovoltaik.Prognose;\n    var verb = obj[i].Prognose.Verb_Std;\n\n    \n    photo = photo.replace(',', '.');\n    photo = parseFloat(photo);\n\n    verb = verb.replace(',', '.');\n    verb = parseFloat(verb);\n\n    q_normal = q_normal + (verb - photo) * preis;\n    q_nominal = q_nominal +e_bn*preis;\n    strompreis.push(preis);\n    e_pv.push(photo);\n    e_v.push(verb);\n\n\n}\n\nobj_temp.data.Strompreis = strompreis;\nobj_temp.data.E_PV = e_pv;\nobj_temp.data.E_V = e_v;\nobj_temp.data.E_BN = e_bn;\nobj_temp.data.E_L_max = el_max;\nobj_temp.data.E_E_max = ee_max;\nobj_temp.data.Q_normal = q_normal;\nobj_temp.data.Q_nominal = q_nominal;\nobj_temp.data.Q_total = q_nominal+q_normal;\nobj_temp.data.SoC_start = soc_0;\nobj_temp.data.SoC_final = soc_23;\nobj_temp.data.SoC_min = soc_min;\nobj_temp.data.SoC_max = soc_max;\nobj_temp.info.Ziel = zielfunktion;\nobj_temp.info.Constraints= condition1 + condition2 + condition3;\n\nflow.set(\"obj_LP\",obj_temp);\nmsg.payload =obj_temp;\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 430,
        "y": 220,
        "wires": [
            [
                "2a1f979f9ba35709"
            ]
        ]
    },
    {
        "id": "f369c89972a88f09",
        "type": "debug",
        "z": "1328b7036b2b840e",
        "name": "solution",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "solution",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 960,
        "y": 160,
        "wires": []
    },
    {
        "id": "6d6215c57f30aa2e",
        "type": "inject",
        "z": "1328b7036b2b840e",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "1000",
        "payloadType": "str",
        "x": 290,
        "y": 680,
        "wires": [
            [
                "094c3cfef3ac6ada"
            ]
        ]
    },
    {
        "id": "094c3cfef3ac6ada",
        "type": "mqtt out",
        "z": "1328b7036b2b840e",
        "name": "",
        "topic": "Befehl",
        "qos": "1",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "028242b8fac5d64b",
        "x": 530,
        "y": 680,
        "wires": []
    },
    {
        "id": "e43a71273161dd7f",
        "type": "comment",
        "z": "1328b7036b2b840e",
        "name": "Diese wird mit der Steuerung verbunden.",
        "info": "",
        "x": 460,
        "y": 740,
        "wires": []
    },
    {
        "id": "23317e6f8211c726",
        "type": "inject",
        "z": "1328b7036b2b840e",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "str",
        "x": 230,
        "y": 360,
        "wires": [
            [
                "b533cdea7a772025"
            ]
        ]
    },
    {
        "id": "aebae15ee4dbbdf0",
        "type": "debug",
        "z": "1328b7036b2b840e",
        "name": "constraints",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "constraints",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 970,
        "y": 200,
        "wires": []
    },
    {
        "id": "07102082a832a947",
        "type": "function",
        "z": "1328b7036b2b840e",
        "name": "Struktur_Anfang",
        "func": "const lpsolver = global.get('lpsolver'); //in settings.js as lpsolver gespeichert!\n\n\nconst problem = {\n    optimize: 'cost',\n    opType: 'min',\n    constraints: {\n        resource1: { max: 10 },\n        resource2: { max: 20 },\n    },\n    variables: {\n        product1: {\n            resource1: 1,\n            resource2: 2,\n            cost: 5,\n        },\n        product2: {\n            resource1: 3,\n            resource2: 1,\n            cost: 8,\n        },\n    },\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 260,
        "y": 440,
        "wires": [
            []
        ]
    },
    {
        "id": "2a881cc46adfc649",
        "type": "function",
        "z": "1328b7036b2b840e",
        "name": "V3",
        "func": "const lpsolver = global.get('lpsolver');\nconst obj = msg.payload;\nconst hours = 24;\nconst e_v = obj.data.E_V;\nconst e_pv = obj.data.E_PV;\nconst e_bn_value = obj.data.E_BN;\nconst e_l_max = obj.data.E_L_max;\nconst e_e_max = obj.data.E_E_max;\nconst q_alt = obj.data.Q_normal;\nconst soc_start = obj.data.SoC_start;\nconst soc_final = obj.data.SoC_final;\nconst soc_min = obj.data.SoC_min;\nconst soc_max = obj.data.SoC_max;\nconst preis = obj.data.Strompreis;\nvar soc = [];\nvar E_L = [];\nvar E_E = [];\nvar E_B = [];\nsoc[0] = soc_start;\nsoc[23]= soc_final;\n\n \n\nconst problem = {\n    optimize: 'Gesamtkosten',\n    opType: 'min',\n    constraints: {\n        E_B: { min: -e_l_max,max: e_e_max },\n        Gesamtkosten: {min:0, max:q_alt}\n    },\n    variables: {},\n};\n\nfor(let i = 0; i<=hours; i++)\n{   \n    var soc_tmp = soc[i];\n\n    E_L[i]= (1 - soc_tmp)*e_bn_value;\n    E_E[i] = soc_tmp *e_bn_value;\n\n    if(i<22)\n    {\n        soc[i+1]=soc_tmp + (E_L[i] - E_E[i])/e_bn_value;\n    }\n    \n    const variableName1 = `E_L${i}`;\n    problem.variables[variableName1] = {\n        E_B: 1,       \n        Gesamtkosten: preis[i],\n    };\n\n    const variableName2 = `E_E${i}`;\n    problem.variables[variableName2] = {\n        E_B: -1,\n        Gesamtkosten: preis[i],\n    };\n\n}\nconst solution = lpsolver.Solve(problem);\nmsg.payload = solution;\nmsg.payload =soc;\nconsole.log(\"Solution:\", solution);\n\n// Access and log individual variables if needed\nconsole.log(\"Optimal values for decision variables:\");\nfor (const variable in solution) {\n    if (solution.hasOwnProperty(variable) && variable !== 'feasible' && variable !== 'result') {\n        console.log(`${variable}: ${solution[variable]}`);\n    }\n}\n\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 590,
        "y": 540,
        "wires": [
            []
        ]
    },
    {
        "id": "23a33c614937f01a",
        "type": "function",
        "z": "1328b7036b2b840e",
        "name": "V2",
        "func": "const lpsolver = global.get('lpsolver');\nvar obj = msg.payload;\nconst hours = 24\nconst e_v_values = obj.data.E_V;\nconst e_pv_values = obj.data.E_PV;\nconst e_bn_value = obj.data.E_BN;\nconst e_e_max = obj.data.E_E_max; \nconst e_l_max = obj.data.E_L_max;\nconst soc_start = obj.data.SoC_start;\nconst soc_max = obj.data.SoC_max;\nconst soc_min = obj.data.SoC_min;\nconst price_values = obj.data.Strompreis; // Annahme: Der Preis ist ein Array von Preisen für jede Stunde\n\nconst e_l_constraints = Array.from({ length: hours }, (_, i) => ({ [`E_L_${i}`]: { max: e_l_max, min: 0 } }));\nconst e_e_constraints = Array.from({ length: hours }, (_, i) => ({ [`E_E_${i}`]: { max: e_e_max, min: 0 } }));\nconst soc_constraints = Array.from({ length: hours }, (_, i) => ({ [`SoC_${i}`]: { max: soc_max, min: soc_min } }));\n\nconst problem = {\n  optimize: 'value',\n  opType: 'min',\n  constraints: {\n    E_L_constraints: e_l_constraints,\n    E_E_constraints: e_e_constraints,\n    SoC_constraints: soc_constraints,\n    Preis_constraints: Array.from({ length: hours }, (_, i) => ({ [`Preis_${i}`]: price_values[i] })),\n  },\n  variables: {\n    \n  },\n  ints: {\n    // Wenn Ganzzahl-Anforderungen vorhanden sind, können sie hier spezifiziert werden\n    // Beispiel: E_Netz: 1, E_V: 1, ...\n  },\n  subjectTo: {\n    // Hier werden die Gleichungen für E_Netz, E_E, E_L und SoC für jede Stunde definiert\n    E_Netz: Array.from({ length: hours }, (_, i) => `E_Netz_${i} = E_V_${i} - E_PV_${i} - E_E_${i} + E_L_${i}`),\n    Gesamtkosten: Array.from({ length: hours }, (_, i) => `Gesamtkosten_${i} = E_Netz_${i} * Preis_${i}`),\n    E_E: Array.from({ length: hours }, (_, i) => `E_E_${i} = E_BN * SoC_${i}`),\n    E_L: Array.from({ length: hours }, (_, i) => `E_L_${i} = E_BN * (1 - SoC_${i})`),\n    SoC: Array.from({ length: hours }, (_, i) => {\n      if (i === 0) {\n        return `SoC_${i} = ${soc_start}`;\n      } else {\n        return `SoC_${i} = SoC_${i - 1} + (E_E_${i - 1} - E_L_${i - 1}) / ${e_bn_value}`;\n      }\n    })\n  },\n  constants: {\n    // Hier wird der konstante Wert für E_BN festgelegt\n    E_BN: e_bn_value\n  }\n};\n\n\nfor (let i = 0; i < hours; i++) {\n\n  const varName3 = `E_E${i}`;\n  problem.variables[varName3] = { E_Netz: -1 };\n  const varName4 = `E_L${i}`;\n  problem.variables[varName4] = { E_Netz: 1 };\n\n}\n\nfor (let i = 0; i < hours; i++) {\n\n  const varName = `SoC${i}`;\n  problem.variables[varName] = {E_E: e_bn_value, E_L: e_bn_value};\n  \n}\n\n\n\n\nconst solution = lpsolver.Solve(problem);\nmsg.solution = solution;\nmsg.constraints =problem.constraints;\nmsg.variables=problem.variables;\n\nif (solution.feasible) {\n  console.log(\"Optimale Lösung gefunden:\");\n  console.log(\"Gesamtkosten:\", solution.result);\n\n  // Zugriff auf die Werte der einzelnen Variablen\n  for (let i = 0; i < hours; i++) {\n    const E_V_value = solution[`E_V_${i}`];\n    const E_PV_value = solution[`E_PV_${i}`];\n    const E_E_value = solution[`E_E_${i}`];\n    const E_L_value = solution[`E_L_${i}`];\n    const SoC_value = solution[`SoC_${i}`];\n    const Gesamtkosten_value = solution[`Gesamtkosten_${i}`];\n\n    console.log(`Stunde ${i + 1}:`);\n    console.log(\"E_V:\", E_V_value);\n    console.log(\"E_PV:\", E_PV_value);\n    console.log(\"E_E:\", E_E_value);\n    console.log(\"E_L:\", E_L_value);\n    console.log(\"SoC:\", SoC_value);\n    console.log(\"Gesamtkosten:\", Gesamtkosten_value);\n    console.log(\"--------------\");\n  }\n} else {\n  console.log(\"Das Modell hat keine zulässige Lösung gefunden.\");\n}\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 590,
        "y": 500,
        "wires": [
            []
        ]
    },
    {
        "id": "884d710753b0d5a4",
        "type": "function",
        "z": "1328b7036b2b840e",
        "name": "V4",
        "func": "const lpsolver = global.get('lpsolver');\nconst obj = msg.payload;\nconst hours = 24;\nconst e_v = obj.data.E_V;\nconst e_pv = obj.data.E_PV;\nconst e_bn_value = obj.data.E_BN;\nconst e_l_max = obj.data.E_L_max;\nconst e_e_max = obj.data.E_E_max;\nconst q_alt = obj.data.Q_normal;\nconst soc_start = obj.data.SoC_start;\nconst soc_final = obj.data.SoC_final;\nconst soc_min = obj.data.SoC_min;\nconst soc_max = obj.data.SoC_max;\nconst preis = obj.data.Strompreis;\nvar soc = [];\nvar e_l = [];\nvar e_e = [];\nvar e_b = [];\nsoc[0] = soc_start;\nsoc[23] = soc_final;\nvar soc_data = 0;\nvar e_e_data = 0;\nvar e_l_data = 0;\nvar e_b_data = 0;\nvar solution = new Object;\n \n\nconst problem = {\n    optimize: 'Gesamtkosten',\n    opType: 'min',\n    constraints: {\n        E_B: { min: -e_l_max,max: e_e_max },\n        Gesamtkosten: { max:q_alt},\n\n    },\n    variables: {},\n};\n\nfor(let i = 0; i<=hours; i++)\n{   \n    var soc_name = \"SoC_\" + (i);\n    var e_e_name = \"E_E_\" + (i);\n    var e_l_name = \"E_L_\" + (i) ;\n    var e_b_name = \"E_B_\" + (i);\n\n    if (i <= 22) {\n    \n        soc_data = soc[i-1]+e_e[i-1];\n        e_e_data = problem.variables[e_e_name];\n        e_l_data = problem.variables[e_l_name];\n        e_b_data = problem.variables[e_b_name];\n    }\n\n    if (i === 0)\n    {\n        soc_data = soc[0];\n        e_e_data = e_bn_value*soc_data;\n        e_l_data = e_bn_value *(1- soc_data);\n        e_b_data =e_l_data-e_e_data;\n    }\n    soc[i]=soc_data;\n    e_e[i]=e_e_data;\n    e_l[i]=e_l_data;\n    e_b[i]=e_b_data;\n\n       \n    const varName4 = `E_B_${i}`;\n    problem.variables[varName4] = {\n        Gesamtkosten: preis[i],\n    }\n    \n    const varName3 = `E_L_${i}`;\n    problem.variables[varName3] = {\n        E_B: 1,\n    }\n    const varName2 = `E_E_${i}`;\n    problem.variables[varName2] = {\n        E_B: -1,\n    }\n    const varName1 = `SoC_${i}`;\n    problem.variables[varName1] = {\n        E_L: (1-soc_data), \n        E_E: soc_data,      \n    };\n\n   solution = lpsolver.Solve(problem);\n\n}\n\nsolution = lpsolver.Solve(problem);\nmsg.payload = solution;\nmsg.payload = problem.variables;\nconsole.log(\"Solution:\", solution);\n\n\n\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 590,
        "y": 580,
        "wires": [
            []
        ]
    },
    {
        "id": "3b59567bdc69bf50",
        "type": "function",
        "z": "1328b7036b2b840e",
        "name": "V5.0",
        "func": "const lpsolver = global.get('lpsolver');\nconst obj = msg.payload;\nconst hours = 24;\nconst e_v = obj.data.E_V;\nconst e_pv = obj.data.E_PV;\nconst e_bn_value = obj.data.E_BN;\nconst e_l_max = obj.data.E_L_max;\nconst e_e_max = obj.data.E_E_max;\nconst q_normal = obj.data.Q_normal;\nconst q_nominal = obj.data.Q_normal;\nconst q_alt = obj.data.Q_Total;\nconst soc_start = obj.data.SoC_start;\nconst soc_final = obj.data.SoC_final;\nconst soc_min = obj.data.SoC_min;\nconst soc_max = obj.data.SoC_max;\nconst preis = obj.data.Strompreis;\nconst constraints = {};\nconst variables = {};\n\n\n// Definition Ihres linearen Programmierungsmodells\n\n\nfor (let i = 1; i <= hours; i++) {\n    constraints[`E_Netz_${i} + E_PV_${i} + E_B_${i} - E_V_${ i }`] = {\n        equal:0\n    };\n}\n\nfor (let i = 1; i <= hours; i++) {\n    constraints[`E_BE_${i}`] = {max: e_e_max};\n}\n\nfor (let i = 1; i <= hours; i++) {\n    constraints[`E_BL_${i}`] = {max: e_l_max};\n}\n\n\n\n// Batterieladung und -entladung für jede Stunde i\nfor (let i = 1; i <= hours; i++) {\n    constraints[`E_B_${i} - E_BL_${i} + E_BE_${i}`] = 0;\n}\n\n// SoC-Begrenzung zwischen 2 und 23\nconstraints[`E_B_1`] = soc_start*e_bn_value;\nfor (let i = 2; i <= hours - 1; i++) {\n    constraints[`0.2 * e_bn_value - E_B_${i}`] = {equal:0};\n    constraints[`E_B_${i} - 0.9 * e_bn_value`] = {equal:0};\n}\nconstraints[`E_B_${hours}`] = soc_final*e_bn_value;\n\n\n//Energie vom Netz in Stunde i\nfor (let i = 1; i <= hours; i++) {\n    variables[`E_Netz_${i}`] = {\n        Kosten: preis[i - 1]\n    } \n}\n\n// Energie aus der PV-Anlage in Stunde i\nfor (let i = 1; i <= hours; i++) {\n    variables[`E_PV_${i}`] = e_pv[i-1];\n}\n\n// Verbrauch in Stunde i\nfor (let i = 1; i <= hours; i++) {\n    variables[`E_V_${i}`] = e_v[i-1];\n}\n\n// E_BE\nfor (let i = 1; i <= hours; i++) {\n    variables[`E_BE_${i}`] = {\n        [ `E_B_${i}` ]: -1,\n    };\n}\n\n// E_BL\nfor (let i = 1; i <= hours; i++) {\n    variables[`E_BL_${i}`]= {\n        [`E_B_${i}`]: 1,\n    };\n}\n\n//variables.Kosten = Array.from({ length: hours }, (_, i) => `E_Netz_${i + 1}`).join(\" + \");\nconst problem = {\n    optimize: \"Kosten\",\n    opType: \"min\",\n    constraints,\n    variables\n};\n\n\n\n// Lösung des linearen Programmierungsproblems\nconst solution = lpsolver.Solve(problem);\n\nmsg.solution = solution;\nmsg.constraints = problem.constraints;\nmsg.variables = problem.variables;\n\nif (solution.feasible) {\n    console.log(\"Optimale Lösung gefunden:\");\n    console.log(\"Gesamtkosten:\", solution.result);\n\n    // Zugriff auf die Werte der einzelnen Variablen\n    for (let i = 0; i < hours; i++) {\n        const E_Netz_value = solution[`E_Netz_${i}`];\n        const E_E_value = solution[`E_E_${i}`];\n        const E_L_value = solution[`E_L_${i}`];\n        const Kosten = solution[`Kosten${i}`];\n\n        console.log(`Stunde ${i + 1}:`);\n        console.log(\"E_Netz:\", E_Netz_value);\n        console.log(\"E_E:\", E_E_value);\n        console.log(\"E_L:\", E_L_value);\n        console.log(\"Kosten:\", Kosten);\n        console.log(\"--------------\");\n    }\n} else {\n    console.log(\"Das Modell hat keine zulässige Lösung gefunden.\");\n}\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1150,
        "y": 300,
        "wires": [
            []
        ]
    },
    {
        "id": "4d6393709520a681",
        "type": "function",
        "z": "1328b7036b2b840e",
        "name": "Vitaminen",
        "func": "const lpsolver = global.get('lpsolver');\n\nconst problem = {\n    optimize: 'total',\n    opType: 'min',\n\n    constraints: {\n        a: { min: 700 },\n        b1: { min: 700 },\n        b2: { min: 700 },\n        b3: { min: 700 },\n        xr: { min: 0 },\n        xh: { min: 0 },\n        xsf: { min: 0 },\n        xka: { min: 0 },\n        xkae: { min: 0 },\n        xf: { min: 0 },\n        xsb: { min: 0 },\n        xtp: { min: 0 },\n    },\n\n    variables: {\n        xr: {\n            a: 60,\n            b1: 10,\n            b2: 15,\n            c: 20,\n            total: 4.19,\n            isInteger: false,\n        },\n        xh: {\n            a: 8,\n            b1: 20,\n            b2: 20,\n            c: 0,\n            total: 3.29,\n            isInteger: false,\n        },\n        xsf: {\n            a: 8,\n            b1: 15,\n            b2: 10,\n            c: 10,\n            total: 3.59,\n            isInteger: false,\n        },\n        xka: {\n            a: 40,\n            b1: 35,\n            b2: 10,\n            c: 40,\n            total: 2.89,\n            isInteger: false,\n        },\n        xkae: {\n            a: 15,\n            b1: 15,\n            b2: 15,\n            c: 35,\n            total: 2.19,\n            isInteger: false,\n        },\n        xf: {\n            a: 70,\n            b1: 15,\n            b2: 15,\n            c: 30,\n            total: 2.59,\n            isInteger: false,\n        },\n        xsb: {\n            a: 25,\n            b1: 25,\n            b2: 15,\n            c: 50,\n            total: 2.59,\n            isInteger: false,\n        },\n        xtp: {\n            a: 60,\n            b1: 10,\n            b2: 10,\n            c: 20,\n            total: 2.39,\n            isInteger: false,\n        }\n    },\n};\n\n\nconst solution = lpsolver.Solve(problem);\nmsg.payload = problem.variables;\nconsole.log(\"Solution:\", solution);\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 600,
        "y": 460,
        "wires": [
            []
        ]
    },
    {
        "id": "26d49839df5704b3",
        "type": "function",
        "z": "1328b7036b2b840e",
        "name": "Army",
        "func": "const lpsolver = global.get('lpsolver'); \n\nconst model = {\n    optimize: 'cost',\n    opType: 'min',\n    constraints: {\n        plane: { min: 44 },\n        person: { min: 400 },\n        cost: { max: 500000 }\n    },\n    variables: {\n        brit: {\n            capacity: 20000,\n            plane: 1,\n            person: 8,\n            cost: 5000\n        },\n        yank: {\n            capacity: 30000,\n            plane: 1,\n            person: 16,\n            cost: 9000\n        }\n    },\n};\n\n\nconst solution = lpsolver.Solve(model);\nmsg.payload =solution;\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 590,
        "y": 420,
        "wires": [
            []
        ]
    },
    {
        "id": "75aeabf687aa4677",
        "type": "function",
        "z": "1328b7036b2b840e",
        "name": "function 3",
        "func": "const lpsolver = global.get('lpsolver'); \n\nconst model = {\n        \"optimize\": \"profit\",\n        \"opType\": \"max\",\n        \"constraints\": {\n            \"wood\": {\"max\": 300},\n            \"labor\": {\"max\": 110},\n            \"storage\": {\"max\": 400}\n        },\n        \"variables\": {\n            \"table\": {\"wood\": 30, \"labor\": 5, \"profit\": 1200, \"table\": 1, \"storage\": 30},\n            \"dresser\": {\"wood\": 20, \"labor\": 10, \"profit\": 1600, \"dresser\": 1, \"storage\": 50}\n        },\n        \"ints\": {\"table\": 1, \"dresser\": 1}\n    }\n\nconst solution = lpsolver.Solve(model);\nmsg.payload =solution;\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 600,
        "y": 620,
        "wires": [
            []
        ]
    },
    {
        "id": "b533cdea7a772025",
        "type": "function",
        "z": "1328b7036b2b840e",
        "name": "Army",
        "func": "const lpsolver = global.get('lpsolver'); \n\nconst model = {\n    optimize: 'cost',\n    opType: 'min',\n    constraints: {\n        plane: { min: 44 },\n        person: { min: 450 },\n        cost: { max: 500000 },\n        \n    },\n    variables: {\n        brit: {\n            capacity: 20000,\n            plane: 1,\n            person: 8,\n            cost: 5000\n        },\n        yank: {\n            capacity: 30000,\n            plane: 1,\n            person: 16,\n            cost: 9000\n        }\n    },\n};\n\nconst solution = lpsolver.Solve(model);\nmsg.payload =solution;\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 510,
        "y": 360,
        "wires": [
            [
                "30089d09c4f69721"
            ]
        ]
    },
    {
        "id": "40cd8a7b4e596bd5",
        "type": "debug",
        "z": "1328b7036b2b840e",
        "name": "variables",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "variables",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 960,
        "y": 240,
        "wires": []
    },
    {
        "id": "f5791d6dc4096d63",
        "type": "debug",
        "z": "1328b7036b2b840e",
        "name": "soc",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "soc",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 950,
        "y": 280,
        "wires": []
    },
    {
        "id": "30089d09c4f69721",
        "type": "debug",
        "z": "1328b7036b2b840e",
        "name": "payload",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 800,
        "y": 360,
        "wires": []
    },
    {
        "id": "b29e33a4a7efdef6",
        "type": "function",
        "z": "1328b7036b2b840e",
        "name": "V5.2",
        "func": "const lpsolver = global.get('lpsolver');\nconst obj = msg.payload;\nconst hours = 24;\nconst e_v = obj.data.E_V;\nconst e_pv = obj.data.E_PV;\nconst e_bn_value = obj.data.E_BN;\nconst e_l_max = obj.data.E_L_max;\nconst e_e_max = obj.data.E_E_max;\nconst q_normal = obj.data.Q_normal;\nconst q_nominal = obj.data.Q_normal;\nconst q_alt = obj.data.Q_Total;\nconst soc_start = obj.data.SoC_start;\nconst soc_final = obj.data.SoC_final;\nconst soc_min = obj.data.SoC_min;\nconst soc_max = obj.data.SoC_max;\nconst preis = obj.data.Strompreis;\nconst constraints = {};\nconst variables = {};\nconst soc = [];\n\n\n//Variables\n// E_BE\nfor (let i = 1; i <= hours; i++) {\n    variables[`E_BE_${i}`] = {\n        [ `E_B_${i}` ]: -1,\n    };\n}\n// E_BL\nfor (let i = 1; i <= hours; i++) {\n    variables[`E_BL_${i}`]= {\n        [`E_B_${i}`]: 1,\n    };\n}\n//EB im E_Netz\nfor (let i = 1; i <= hours; i++) {\n    variables[`E_B_${i}`] = {\n        [`E_Netz_${i}`]: 1,\n    };\n}\n// Energie aus der PV-Anlage in Stunde i\nfor (let i = 1; i <= hours; i++) {\n    variables[`E_PV_${i}`] = e_pv[i - 1];\n}\n// Verbrauch in Stunde i\nfor (let i = 1; i <= hours; i++) {\n    variables[`E_V_${i}`] = e_v[i - 1];\n}\n//Energie vom Netz in Stunde i\nfor (let i = 1; i <= hours; i++) {\n    variables[`E_Netz_${i}`] = {\n        Kosten: preis[i - 1]\n    } \n}\n\n\n//Constraints\n// Definition Ihres linearen Programmierungsmodells\n\n//E_BE Begrenzung\nfor (let i = 1; i <= hours; i++) {\n    constraints[`E_BE_${i}`] = { max: e_e_max};\n}\n\n//E_BL Begrenzung\nfor (let i = 1; i <= hours; i++) {\n    constraints[`E_BL_${i}`] = { max: e_l_max };\n}\n\n\n// E_B Begrenzung\nfor (let i = 1; i <= hours - 1; i++) {\n    constraints[`E_B_${i}`] = {\n        min: -e_e_max,\n        max: e_l_max\n    };\n}\n\n\nfor (let i = 1; i <= hours; i++) {\n    constraints[`E_Netz_${i} + E_PV_${i} - E_B_${i} - E_V_${ i }`] = \n    {\n        equal: 0,\n    };\n}\n\nconst problem = {\n    optimize: \"Kosten\",\n    opType: \"min\",\n    constraints,\n    variables\n};\n\n\n\n// Lösung des linearen Programmierungsproblems\nconst solution = lpsolver.Solve(problem);\n\nmsg.solution = solution;\nmsg.constraints = problem.constraints;\nmsg.variables = problem.variables;\nmsg.soc =soc;\n\nif (solution.feasible) {\n    console.log(\"Optimale Lösung gefunden:\");\n    console.log(\"Gesamtkosten:\", solution.result);\n\n    // Zugriff auf die Werte der einzelnen Variablen\n    for (let i = 0; i < hours; i++) {\n        const E_Netz_value = solution[`E_Netz_${i}`];\n        const E_BE_value = solution[`E_BE_${i}`];\n        const E_BL_value = solution[`E_BL_${i}`];\n        const Kosten = solution[`Kosten${i}`];\n\n        console.log(`Stunde ${i + 1}:`);\n        console.log(\"E_Netz:\", E_Netz_value);\n        console.log(\"E_BE:\", E_BE_value);\n        console.log(\"E_BL:\", E_BL_value);\n        console.log(\"Kosten:\", Kosten);\n        console.log(\"--------------\");\n    }\n} else {\n    console.log(\"Das Modell hat keine zulässige Lösung gefunden.\");\n}\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1150,
        "y": 260,
        "wires": [
            []
        ]
    },
    {
        "id": "2ec31048d42f3b37",
        "type": "function",
        "z": "1328b7036b2b840e",
        "name": "V5.3",
        "func": "const lpsolver = global.get('lpsolver');\nconst obj = msg.payload;\nconst hours = 24;\nconst e_v = obj.data.E_V;\nconst e_pv = obj.data.E_PV;\nconst e_bn_value = obj.data.E_BN;\nconst e_l_max = obj.data.E_L_max;\nconst e_e_max = obj.data.E_E_max;\nconst q_normal = obj.data.Q_normal;\nconst q_nominal = obj.data.Q_normal;\nconst q_alt = obj.data.Q_Total;\nconst soc_start = obj.data.SoC_start;\nconst soc_final = obj.data.SoC_final;\nconst soc_min = obj.data.SoC_min;\nconst soc_max = obj.data.SoC_max;\nconst preis = obj.data.Strompreis;\nconst constraints = {};\nconst variables = {};\nconst soc = [];\n\n\n//Variables\n// E_V\nfor (let i = 1; i <= hours; i++) {\n    variables[`E_V_${i}`] = {\n        [`E_Netz_${i}`]: 1,\n    };\n}\n\n// E_PV\nfor (let i = 1; i <= hours; i++) {\n    variables[`E_PV_${i}`] = {\n        [`E_Netz_${i}`]: -1,\n    };\n}\n\n// E_BE\nfor (let i = 1; i <= hours; i++) {\n    variables[`E_BE_${i}`] = {\n        [ `E_B_${i}` ]: -1,\n    };\n}\n// E_BL\nfor (let i = 1; i <= hours; i++) {\n    variables[`E_BL_${i}`]= {\n        [`E_B_${i}`]: 1,\n    };\n}\n//EB im E_Netz\nfor (let i = 1; i <= hours; i++) {\n    variables[`E_B_${i}`] = {\n        [`E_Netz_${i}`]: 1,\n    };\n}\n\n//Energie vom Netz in Stunde i\nfor (let i = 1; i <= hours; i++) {\n    variables[`E_Netz_${i}`] = {\n        Kosten: preis[i - 1]\n    } \n}\n\n\n//Constraints\n// Definition Ihres linearen Programmierungsmodells\n\nfor (let i = 1; i <= hours; i++) {\n    constraints[`E_V_${i}`] = { equal:e_v[i - 1]};\n}\n\nfor (let i = 1; i <= hours; i++) {\n    constraints[`E_PV_${i}`] = { equal:e_pv[i - 1]};\n}\n\n//E_BE Begrenzung\nfor (let i = 1; i <= hours; i++) {\n    constraints[`E_BE_${i}`] = { max: e_e_max};\n}\n\n//E_BL Begrenzung\nfor (let i = 1; i <= hours; i++) {\n    constraints[`E_BL_${i}`] = { max: e_l_max };\n}\n\n// E_B Begrenzung\nfor (let i = 1; i <= hours - 1; i++) {\n    constraints[`E_B_${i}`] = {\n        min: -e_e_max,\n        max: e_l_max\n    };\n}\n\nfor (let i = 1; i <= hours; i++) {\n    constraints[`E_Netz_${i} + E_PV_${i} - E_B_${i} - E_V_${ i }`] = \n    {\n        equal: 0,\n    };\n}\n\nconst problem = {\n    optimize: \"Kosten\",\n    opType: \"min\",\n    constraints,\n    variables\n};\n\n\n\n// Lösung des linearen Programmierungsproblems\nconst solution = lpsolver.Solve(problem);\n\nmsg.solution = solution;\nmsg.constraints = problem.constraints;\nmsg.variables = problem.variables;\nmsg.soc =soc;\n\nif (solution.feasible) {\n    console.log(\"Optimale Lösung gefunden:\");\n    console.log(\"Gesamtkosten:\", solution.result);\n\n    // Zugriff auf die Werte der einzelnen Variablen\n    for (let i = 0; i < hours; i++) {\n        const E_Netz_value = solution[`E_Netz_${i}`];\n        const E_BE_value = solution[`E_BE_${i}`];\n        const E_BL_value = solution[`E_BL_${i}`];\n        const Kosten = solution[`Kosten${i}`];\n\n        console.log(`Stunde ${i + 1}:`);\n        console.log(\"E_Netz:\", E_Netz_value);\n        console.log(\"E_BE:\", E_BE_value);\n        console.log(\"E_BL:\", E_BL_value);\n        console.log(\"Kosten:\", Kosten);\n        console.log(\"--------------\");\n    }\n} else {\n    console.log(\"Das Modell hat keine zulässige Lösung gefunden.\");\n}\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1150,
        "y": 220,
        "wires": [
            []
        ]
    },
    {
        "id": "6fdbafc048f66c37",
        "type": "function",
        "z": "1328b7036b2b840e",
        "name": "V5.4",
        "func": "const lpsolver = global.get('lpsolver');\nconst obj = msg.payload;\nconst hours = 24;\nconst e_v = obj.data.E_V;\nconst e_pv = obj.data.E_PV;\nconst e_bn_value = obj.data.E_BN;\nconst e_l_max = obj.data.E_L_max;\nconst e_e_max = obj.data.E_E_max;\nconst q_normal = obj.data.Q_normal;\nconst q_nominal = obj.data.Q_normal;\nconst q_alt = obj.data.Q_Total;\nconst soc_start = obj.data.SoC_start;\nconst soc_final = obj.data.SoC_final;\nconst soc_min = obj.data.SoC_min;\nconst soc_max = obj.data.SoC_max;\nconst preis = obj.data.Strompreis;\nconst constraints = {};\nconst variables = {};\nconst soc = [];\n\n\n//Variables\n// E_BE\nfor (let i = 1; i <= hours; i++) {\n    variables[`E_BE_${i}`] = {\n        [ `E_B_${i}` ]: -1,\n    };\n}\n// E_BL\nfor (let i = 1; i <= hours; i++) {\n    variables[`E_BL_${i}`]= {\n        [`E_B_${i}`]: 1,\n    };\n}\n//EB im E_Netz\nfor (let i = 1; i <= hours; i++) {\n    variables[`E_B_${i}`] = {\n        [`E_Netz_${i}`]: 1,\n    };\n}\n// Energie aus der PV-Anlage in Stunde i\nfor (let i = 1; i <= hours; i++) {\n    variables[`E_PV_${i}`] = e_pv[i - 1];\n}\n// Verbrauch in Stunde i\nfor (let i = 1; i <= hours; i++) {\n    variables[`E_V_${i}`] = e_v[i - 1];\n}\n//Energie vom Netz in Stunde i\nfor (let i = 1; i <= hours; i++) {\n    variables[`E_Netz_${i}`] = {\n        Kosten: preis[i - 1]\n    } \n}\n\n\n//Constraints\n// Definition Ihres linearen Programmierungsmodells\n\n//E_BE Begrenzung\nfor (let i = 1; i <= hours; i++) {\n    constraints[`E_BE_${i}`] = { max: e_e_max};\n}\n\n//E_BL Begrenzung\nfor (let i = 1; i <= hours; i++) {\n    constraints[`E_BL_${i}`] = { max: e_l_max };\n}\n\n//E_PV Begrenzung\nfor (let i = 1; i <= hours; i++) {\n    constraints[`E_PV_${i}`] = {min: 0 };\n}\n//E_V Begrenzung\nfor (let i = 1; i <= hours; i++) {\n    constraints[`E_V_${i}`] = {min: 0 };\n}\n\n\n// E_B Begrenzung\nfor (let i = 1; i <= hours - 1; i++) {\n    constraints[`E_B_${i}`] = {\n        min: -e_e_max,\n        max: e_l_max\n    };\n}\n\n\nfor (let i = 1; i <= hours; i++) {\n    constraints[`E_Netz_${i} + E_PV_${i} - E_B_${i} - E_V_${ i }`] = \n    {\n        equal: 0,\n    };\n}\n\nconst problem = {\n    optimize: \"Kosten\",\n    opType: \"min\",\n    constraints,\n    variables\n};\n\n\n\n// Lösung des linearen Programmierungsproblems\nconst solution = lpsolver.Solve(problem);\n\nmsg.solution = solution;\nmsg.constraints = problem.constraints;\nmsg.variables = problem.variables;\nmsg.soc =soc;\n\nif (solution.feasible) {\n    console.log(\"Optimale Lösung gefunden:\");\n    console.log(\"Gesamtkosten:\", solution.result);\n\n    // Zugriff auf die Werte der einzelnen Variablen\n    for (let i = 0; i < hours; i++) {\n        const E_Netz_value = solution[`E_Netz_${i}`];\n        const E_BE_value = solution[`E_BE_${i}`];\n        const E_BL_value = solution[`E_BL_${i}`];\n        const Kosten = solution[`Kosten${i}`];\n\n        console.log(`Stunde ${i + 1}:`);\n        console.log(\"E_Netz:\", E_Netz_value);\n        console.log(\"E_BE:\", E_BE_value);\n        console.log(\"E_BL:\", E_BL_value);\n        console.log(\"Kosten:\", Kosten);\n        console.log(\"--------------\");\n    }\n} else {\n    console.log(\"Das Modell hat keine zulässige Lösung gefunden.\");\n}\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 590,
        "y": 260,
        "wires": [
            [
                "f369c89972a88f09",
                "aebae15ee4dbbdf0",
                "40cd8a7b4e596bd5",
                "f5791d6dc4096d63"
            ]
        ]
    },
    {
        "id": "f5f06eb357441354",
        "type": "function",
        "z": "1328b7036b2b840e",
        "name": "Test",
        "func": "const lpsolver = global.get('lpsolver');\nconst obj = msg.payload;\nconst hours = 24;\nconst e_v = obj.data.E_V;\nconst e_pv = obj.data.E_PV;\nconst e_bn_value = obj.data.E_BN;\nconst e_l_max = obj.data.E_L_max;\nconst e_e_max = obj.data.E_E_max;\nconst q_normal = obj.data.Q_normal;\nconst q_nominal = obj.data.Q_normal;\nconst q_alt = obj.data.Q_Total;\nconst soc_start = obj.data.SoC_start;\nconst soc_final = obj.data.SoC_final;\nconst soc_min = obj.data.SoC_min;\nconst soc_max = obj.data.SoC_max;\nconst preis = obj.data.Strompreis;\nconst constraints = {};\nconst variables = {};\nvar soc = [];\nvar e_e = [];\nvar e_l = [];\nvar y_b = false; \n\nsoc[0]= soc_start;\nsoc[23]=soc_final;\n//was soll als erstes gemacht werden? Laden oder Entladen?\nif(soc[0]<0.5)\n{\n    y_b=true; //Laden\n}else\n{\n    y_b=false; //Entladen\n}\n\n\n//Variables\n//Soc\nfor (let i = 0; i < hours-2; i++) {\n    var soc_temp = soc[i];\n    var e_e_temp = 0;\n    var e_l_temp = 0;\n\n    if (soc_temp < 0.5) {\n        y_b = true; //Laden\n    } else {\n        y_b = false; //Entladen\n    }\n    if(y_b)\n    {\n        e_l_temp =e_bn_value*(soc_max-soc_temp);\n        e_e_temp =0;\n    }else\n    {\n        e_e_temp = e_bn_value * (soc_temp - soc_min);\n        e_l_temp = 0;\n    }\n    soc[i+1]=soc_temp + (e_l_temp - e_e_temp)/e_bn_value;\n    e_e[i]=e_e_temp;\n    e_l[i]=e_l_temp;\n}\n\n//ebn\nfor (let i = 1; i <= hours; i++) {\n    variables[`E_BN_${i}`] = {\n        [`E_Netz_${i}`]: preis[i-1],\n    };\n}\n\n\n// E_V\nfor (let i = 1; i <= hours; i++) {\n    variables[`E_V_${i}`] = {\n        [`E_Netz_${i}`]: preis[i-1],\n    };\n}\n\n// E_PV\nfor (let i = 1; i <= hours; i++) {\n    variables[`E_PV_${i}`] = {\n        [`E_Netz_${i}`]: -preis[i-1],\n    };\n}\n\n// E_BE\nfor (let i = 1; i <= hours; i++) {\n\n    variables[`E_BE_${i}`] = {\n        [`E_B_${i}`]: -preis[i - 1],\n    };\n    if (i == 1) {\n        variables[`E_BE_0`] = {\n            [`E_B_${i}`]: -1,\n        };\n    }\n}\n\n// E_BL\nfor (let i = 1; i <= hours; i++) {\n    variables[`E_BL_${i}`] = {\n        [`E_B_${i}`]: preis[i - 1],\n    };\n    if (i == 1) {\n        variables[`E_BL_0`] = {\n            [`E_B_${i}`]: 1,\n        };\n    }\n}\n\n//EB im E_Netz\nfor (let i = 1; i <= hours; i++) {\n    variables[`E_B_${i}`] = {\n        [`E_Netz_${i}`]: 1,\n    };\n}\n\n//Energie vom Netz in Stunde i\nfor (let i = 1; i <= hours; i++) {\n    variables[`E_Netz_${i}`] = {\n        Kosten: preis[i - 1]\n    } \n}\n\n\n//Constraints\n// Definition Ihres linearen Programmierungsmodells\n\nfor (let i = 1; i <= hours; i++) {\n    constraints[`E_V_${i}`] = { equal:e_v[i - 1]};\n}\n\nfor (let i = 1; i <= hours; i++) {\n    constraints[`E_PV_${i}`] = { equal:e_pv[i - 1]};\n}\n\n//E_BE Begrenzung\nfor (let i = 1; i <= hours; i++) {\n    constraints[`E_BE_${i}`] = { equal:e_e[i-1], max: e_e_max};\n}\n\n//E_BL Begrenzung\nfor (let i = 1; i <= hours; i++) {\n    \n    constraints[`E_BL_${i}`] = { equal:e_l[i-1], max: e_l_max };\n}\n\n// E_B Begrenzung\nfor (let i = 1; i <= hours - 1; i++) {\n    constraints[`E_B_${i}`] = {\n        min: -e_e_max,\n        max: e_l_max\n    };\n}\n\nfor (let i = 1; i <= hours; i++) {\n    constraints[`E_Netz_${i} + E_PV_${i} - E_B_${i} - E_V_${ i }`] = \n    {\n        equal: 0,\n    };\n}\n\nconst problem = {\n    optimize: \"Kosten\",\n    opType: \"min\",\n    constraints,\n    variables\n};\n\n\n\n// Lösung des linearen Programmierungsproblems\nconst solution = lpsolver.Solve(problem);\n\nmsg.solution = solution;\nmsg.constraints = problem.constraints;\nmsg.variables = problem.variables;\nmsg.soc =e_e;\n\nif (solution.feasible) {\n    console.log(\"Optimale Lösung gefunden:\");\n    console.log(\"Gesamtkosten:\", solution.result);\n\n    // Zugriff auf die Werte der einzelnen Variablen\n    for (let i = 0; i < hours; i++) {\n        const E_Netz_value = solution[`E_Netz_${i}`];\n        const E_BE_value = solution[`E_BE_${i}`];\n        const E_BL_value = solution[`E_BL_${i}`];\n        const Kosten = solution[`Kosten${i}`];\n\n        console.log(`Stunde ${i + 1}:`);\n        console.log(\"E_Netz:\", E_Netz_value);\n        console.log(\"E_BE:\", E_BE_value);\n        console.log(\"E_BL:\", E_BL_value);\n        console.log(\"Kosten:\", Kosten);\n        console.log(\"--------------\");\n    }\n} else {\n    console.log(\"Das Modell hat keine zulässige Lösung gefunden.\");\n}\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 590,
        "y": 180,
        "wires": [
            [
                "f369c89972a88f09",
                "aebae15ee4dbbdf0",
                "40cd8a7b4e596bd5",
                "f5791d6dc4096d63"
            ]
        ]
    },
    {
        "id": "2a1f979f9ba35709",
        "type": "function",
        "z": "1328b7036b2b840e",
        "name": "V5.4 - SoC berechnet",
        "func": "const lpsolver = global.get('lpsolver');\nconst obj = msg.payload;\nconst hours = 24;\nconst e_v = obj.data.E_V;\nconst e_pv = obj.data.E_PV;\nconst e_bn_value = obj.data.E_BN;\nconst e_l_max = obj.data.E_L_max;\nconst e_e_max = obj.data.E_E_max;\nconst q_normal = obj.data.Q_normal;\nconst q_nominal = obj.data.Q_normal;\nconst q_alt = obj.data.Q_Total;\nconst soc_start = obj.data.SoC_start;\nconst soc_final = obj.data.SoC_final;\nconst soc_min = obj.data.SoC_min;\nconst soc_max = obj.data.SoC_max;\nconst preis = obj.data.Strompreis;\nconst constraints = {};\nconst variables = {};\nvar soc = [];\nvar e_e = [];\nvar e_l = [];\nvar y_b = false; \n\nsoc[0]= soc_start;\nsoc[23]=soc_final;\n//was soll als erstes gemacht werden? Laden oder Entladen?\n\nif(soc[0]<0.5)\n{\n    y_b=true; //Laden\n}else\n{\n    y_b=false; //Entladen\n}\n\n\nfor (let i = 0; i < hours-2; i++) {\n    var soc_temp = soc[i];\n    var e_e_temp = 0;\n    var e_l_temp = 0;\n\n    if (soc_temp < 0.5) {\n        y_b = true; //Laden\n    } else {\n        y_b = false; //Entladen\n    }\n    if(y_b)\n    {\n        e_l_temp =e_bn_value*(soc_max-soc_temp);\n        e_e_temp =0;\n    }else\n    {\n        e_e_temp = e_bn_value * (soc_temp - soc_min);\n        e_l_temp = 0;\n    }\n    soc[i+1]=soc_temp + (e_l_temp - e_e_temp)/e_bn_value;\n    e_e[i]=e_e_temp;\n    e_l[i]=e_l_temp;\n}\n\n//Variables\n// E_BE\nfor (let i = 1; i <= hours; i++) {\n    variables[`E_BE_${i}`] = {\n        [ `E_B_${i}` ]: -1,\n    };\n}\n// E_BL\nfor (let i = 1; i <= hours; i++) {\n    variables[`E_BL_${i}`]= {\n        [`E_B_${i}`]: 1,\n    };\n}\n//EB im E_Netz\nfor (let i = 1; i <= hours; i++) {\n    variables[`E_B_${i}`] = {\n        [`E_Netz_${i}`]: 1,\n    };\n}\n// Energie aus der PV-Anlage in Stunde i\nfor (let i = 1; i <= hours; i++) {\n    variables[`E_PV_${i}`] = e_pv[i - 1];\n}\n// Verbrauch in Stunde i\nfor (let i = 1; i <= hours; i++) {\n    variables[`E_V_${i}`] = e_v[i - 1];\n}\n//Energie vom Netz in Stunde i\nfor (let i = 1; i <= hours; i++) {\n    variables[`E_Netz_${i}`] = {\n        Kosten: preis[i - 1]\n    } \n}\n\n\n//Constraints\n// Definition Ihres linearen Programmierungsmodells\n\n//E_BE Begrenzung\nfor (let i = 1; i <= hours; i++) {\n    constraints[`E_BE_${i}`] = { max: e_e_max};\n}\n\n//E_BL Begrenzung\nfor (let i = 1; i <= hours; i++) {\n    constraints[`E_BL_${i}`] = { max: e_l_max };\n}\n\n//E_PV Begrenzung\nfor (let i = 1; i <= hours; i++) {\n    constraints[`E_PV_${i}`] = {min: 0 };\n}\n//E_V Begrenzung\nfor (let i = 1; i <= hours; i++) {\n    constraints[`E_V_${i}`] = {min: 0 };\n}\n\n\n// E_B Begrenzung\nfor (let i = 1; i <= hours - 1; i++) {\n    constraints[`E_B_${i}`] = {\n        min: -e_e_max,\n        max: e_l_max\n    };\n}\n\n\nfor (let i = 1; i <= hours; i++) {\n    constraints[`E_Netz_${i} + E_PV_${i} - E_B_${i} - E_V_${ i }`] = \n    {\n        equal: 0,\n    };\n}\n\nconst problem = {\n    optimize: \"Kosten\",\n    opType: \"min\",\n    constraints,\n    variables\n};\n\n\n\n// Lösung des linearen Programmierungsproblems\nconst solution = lpsolver.Solve(problem);\n\nmsg.solution = solution;\nmsg.constraints = problem.constraints;\nmsg.variables = problem.variables;\nmsg.soc =soc;\n\nif (solution.feasible) {\n    console.log(\"Optimale Lösung gefunden:\");\n    console.log(\"Gesamtkosten:\", solution.result);\n\n    // Zugriff auf die Werte der einzelnen Variablen\n    for (let i = 0; i < hours; i++) {\n        const E_Netz_value = solution[`E_Netz_${i}`];\n        const E_BE_value = solution[`E_BE_${i}`];\n        const E_BL_value = solution[`E_BL_${i}`];\n        const Kosten = solution[`Kosten${i}`];\n\n        console.log(`Stunde ${i + 1}:`);\n        console.log(\"E_Netz:\", E_Netz_value);\n        console.log(\"E_BE:\", E_BE_value);\n        console.log(\"E_BL:\", E_BL_value);\n        console.log(\"Kosten:\", Kosten);\n        console.log(\"--------------\");\n    }\n} else {\n    console.log(\"Das Modell hat keine zulässige Lösung gefunden.\");\n}\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 640,
        "y": 220,
        "wires": [
            [
                "f369c89972a88f09",
                "aebae15ee4dbbdf0",
                "40cd8a7b4e596bd5",
                "f5791d6dc4096d63"
            ]
        ]
    },
    {
        "id": "028242b8fac5d64b",
        "type": "mqtt-broker",
        "name": "",
        "broker": "10.55.6.120",
        "port": "1883",
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": "3",
        "keepalive": "60",
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    }
]